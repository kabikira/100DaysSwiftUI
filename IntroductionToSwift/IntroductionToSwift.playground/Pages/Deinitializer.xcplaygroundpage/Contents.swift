//: [Previous](@previous)

import Foundation

"""
Swift のクラスは、オプションとして、deinitializer を与えることができます。これは、オブジェクトが作成されたときではなく、破棄されたときに呼び出されるという点で、イニシャライザーの反対のようなものです。

これには、いくつかの小さな但し書きがあります。

イニシャライザーと同じように、deinitializersにもfuncを使わないでください - これらは特別です。
初期化子と同様に、初期化子には func を使わないでください。
クラスインスタンスの最終コピーが破棄されるときに、自動的に非初期化プログラムが呼び出されます。これは、例えば、現在終了している関数の内部で作成されたことを意味するかもしれません。
私たちが直接deinitializerを呼び出すことはなく、システムによって自動的に処理されます。
構造体はコピーできないので、deinitializersを持ちません。
いつ初期化子を呼び出すかは、何をするかによりますが、スコープと呼ばれる概念に帰着します。スコープとは多かれ少なかれ「情報が利用可能なコンテキスト」を意味し、すでに多くの例を見てきたと思います。

関数の中で変数を作ると、関数の外からはアクセスできない。
関数の中で変数を作ると、関数の外からその変数にアクセスできない。
forループの中で変数を作ると、そのループの変数自体も含めて、ループの外では使えません。
全体像を見てみると、条件、ループ、関数はいずれも中括弧を使ってスコープを作っていることがわかる。

値がスコープを抜けるということは、その値が作成されたコンテキストがなくなるということです。構造体の場合はデータが破壊されることを意味しますが、クラスの場合は基礎となるデータの1つのコピーだけが消えていくことを意味します（他の場所にまだコピーがあるかもしれません）。しかし、最後のコピー、つまりクラスインスタンスを指す最後の定数や変数が破棄されると、基礎となるデータも破棄され、それが使用していたメモリがシステムに戻されます。

このことを示すために、イニシャライザーとデインシャライザーを使って、作成時と破棄時にメッセージを表示するクラスを作成することができます。
"""
class User {
    let id: Int

    init(id: Int) {
        self.id = id
        print("User \(id): I'm alive!")
    }

    deinit {
        print("User \(id): I'm dead!")
    }
}
"""
ループの中でUserのインスタンスを作成すると、ループの反復が終了した時点で破棄されます。
"""
//for i in 1...3 {
//    let user = User(id: i)
//    print("User \(user.id): I'm in control!")
//}

"""
このコードを実行すると、各ユーザーの作成と削除が個別に行われ、あるユーザーが完全に削除された後に別のユーザーが作成されることがわかります。

deinitializer が呼ばれるのは、クラスインスタンスへの最後の参照が破棄されたときだけであることを思い出してください。これは、あなたが隠しておいた変数や定数かもしれませんし、配列に何かを保存していたかもしれません。

例えば、Userインスタンスを生成するたびに追加していた場合、配列がクリアされたときにのみ破棄されます。
"""
var users = [User]()

for i in 1...3 {
    let user = User(id: i)
    print("User \(user.id): I'm in control!")
    users.append(user)
}

print("Loop is finished!")
users.removeAll()
print("Array is clear!")
