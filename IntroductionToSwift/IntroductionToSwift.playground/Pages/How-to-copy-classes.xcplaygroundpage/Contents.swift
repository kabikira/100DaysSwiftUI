//: [Previous](@previous)

import Foundation

"""
Swift では、クラスインスタンスのすべてのコピーが同じデータを共有し、1 つのコピーに加えた変更は、自動的に他のコピーを変更することを意味します。これは、クラスが Swift の参照型であり、クラスのすべてのコピーが、データの同じ基礎となるポットを参照することを意味するからです。

これを実際に見るために、この単純なクラスを試してみてください。


"""
class User {
    var username = "Anonymous"
}
"""
このプロパティは1つだけですが、クラス内に格納されているため、そのクラスのすべてのコピーで共有されます。

そこで、そのクラスのインスタンスを作成することができます。
"""
var user1 = User()
"""
そして、user1 のコピーを取って、username の値を変更することができます。
"""
var user2 = user1
user2.username = "Taylor"
"""
この流れがおわかりいただけたでしょうか？さて、コピーのユーザー名プロパティを変更したので、同じプロパティをそれぞれの異なるコピーからプリントアウトすることができます。
"""
print(user1.username)
print(user2.username)
"""
片方のインスタンスを変更しただけなのに、もう片方のインスタンスも変更されています。

これはバグのように見えるかもしれませんが、実際には機能です。そして、アプリのすべての部分にわたって共通のデータを共有できるようにするものなので、本当に重要な機能でもあります。見てわかるように、SwiftUIはデータのためにクラスに非常に大きく依存しています。特に、とても簡単に共有できるためです。

比較すると、構造体はコピーの間でデータを共有しません。つまり、私たちのコードでクラスUserを構造体Userに変更すると、異なる結果が得られます：コピーを変更してもオリジナルを調整しなかったので、「Anonymous」そして「Taylor」と表示されます。

クラスインスタンスのユニークなコピー（ディープコピーと呼ばれることもあります）を作成する場合は、新しいインスタンスの作成とすべてのデータのコピーを安全に処理する必要があります。

私たちの場合、それは簡単です。
"""

class User {
    var username = "Anonymous"

    func copy() -> User {
        let user = User()
        user.username = username
        return user
    }
}
"""
これで安全に copy() を呼び出して、同じ開始データを持つオブジェクトを取得することができます。
"""
let str = "a,b,cde,fgh.ijk.lmn"
let list = str.components(separatedBy: CharacterSet(charactersIn: ",."))
Swift.print(list)

// -> ["a", "b", "cde", "fgh", "ijk", "lmn"]
