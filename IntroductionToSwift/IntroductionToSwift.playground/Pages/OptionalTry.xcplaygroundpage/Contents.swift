//: [Previous](@previous)

import Foundation

"""
エラーを投げる可能性のある関数を呼び出す場合、try を使って呼び出し、エラーを適切に処理するか、その関数が失敗しないと確信がある場合は try!(ネタバレ: try!を使うのは非常に稀です。)

関数が成功したか失敗したかにしか興味がない場合は、オプションのtryを使用して、関数がオプションの値を返すようにすることができます。もし関数が何のエラーも出さずに実行されたのなら、オプショナルには戻り値が含まれます。この場合、どのようなエラーが発生したのかを正確に知ることはできませんが、関数が成功したかどうかだけを考えればよい場合もあります。

このような感じです。
"""

enum UserError: Error {
    case badID, networkFailed
}

func getUser(id: Int) throws -> String {
    throw UserError.networkFailed
}

if let user = try? getUser(id: 23) {
    print("User: \(user)")
}
print(user)
"""
getUser()関数は常にnetworkFailedエラーを投げるので、テスト目的には問題ありませんが、実際にはどんなエラーが投げられたかは気にしません。

try?はgetUser()がオプションの文字列を返すようにし、エラーがスローされた場合はnilを返すようにします。どのようなエラーが発生したのかを正確に知りたいのであれば、この方法は役に立ちませんが、多くの場合、気にすることはありません。

必要であれば、try?とnilを組み合わせて、「この関数の戻り値を取得しようとするが、失敗した場合は代わりにこのデフォルト値を使用する」という意味にすることができます。

しかし、注意してください：Swiftがあなたが意味することを正確に理解するように、nil合体の前にいくつかの括弧を追加する必要があります。例えば、あなたはこれを書きます。
"""
let user = (try? getUser(id: 23)) ?? "Anonymous"
print(user)
"""
try?は主に3つの場所で使われていることがわかります。

ガードレットとの組み合わせで、try?の呼び出しがnilを返した場合に現在の関数を終了させる。
nil合体との組み合わせで、何かを試行したり、失敗時のデフォルト値を提供する。
戻り値のないthrow関数を呼び出すとき、それが成功したかどうかを純粋に気にしないとき - たとえば、ログファイルに書き込んだり、サーバーに分析を送信したりするときなど。

"""

