//: [Previous](@previous)

import Foundation

"""
オプショナルチェイニングは、オプショナル中のオプショナルを読み取るための簡略化された構文です。滅多に使わないように思えるかもしれませんが、例を挙げればなぜ便利なのかがわかると思います。

このコードを見てください。
"""
let names = ["Arya", "Bran", "Robb", "Sansa"]

let chosen = names.randomElement()?.uppercased() ?? "No one"
print("Next in line: \(chosen)")

"""
nil合体演算子がオプショナルが空の場合のデフォルト値を提供するのに役立つことはすでに説明しましたが、その前に、クエスチョンマークの後にさらにコードが続くオプショナルチェイニングがあることをご存知でしょう。

オプショナルチェーンでは、「もしオプショナルに値があれば、それをアンラップして...」と、さらにコードを追加していくことができます。今回の例では、「もし配列からランダムな要素を取得できたら、それを大文字にする」と言っています。randomElement() がオプショナルを返すのは、配列が空である可能性があるからであることを忘れないでください。

オプショナルチェインの利点は、オプショナルが空だった場合に何もしないことです。つまり、オプショナルチェーンの返り値は常にオプショナルであり、デフォルト値を提供するために nil 結合が必要なのはそのためです。

オプショナルチェーンは好きなだけ長くすることができ、どこかが nil を送り返すとすぐに残りの行は無視され、nil が送り返されます。

例えば、本を著者名からアルファベット順に並べたいとします。これをそのまま分解すると

Book構造体のオプショナル インスタンスがあります。
この本には著者がいるかもしれませんし、匿名かもしれません。
著者の文字列がある場合、それは空文字列であったり、テキストであったりするので、最初の文字があるかどうかは常に信頼できるわけではありません。
もし最初の文字があれば、それが大文字であることを確認し、 bell hooks のような小文字の名前を持つ著者が正しくソートされるようにします。
以下のようになります。
"""
struct Book {
    let title: String
    let author: String?
}

//var book: Book? = nil
var book: Book? = Book(title: "パンク侍斬られて候", author: "matida ko")

let author = book?.author?.first?.uppercased() ?? "A"
// titleはnilを許容しない型なので？をつけられない
//let author = book?.title.first?.uppercased() ?? "A"
print(author)
"""
つまり、「本があって、その本に著者がいて、著者に頭文字があれば、大文字にして送り返す、そうでなければAを送り返す」と読み取れるわけです。

確かにオプションでそこまで掘り下げることはないでしょうが、構文がいかに楽しく短いか、おわかりいただけたでしょうか？

"""

func sayHello() {
    print("Hello!!")
}
let say: ()? = nil
print(say)


let credentials = ["twostraws", "fr0sties"]
let lowercaseUsername = credentials.first?.lowercased()
