//: [Previous](@previous)

import Foundation

"""

Swift は String、Int、Double、Array などのほとんどのデータ型を保存するために構造体を使用しますが、クラスと呼ばれるカスタムのデータ型を作成する別の方法があります。これらは構造体と多くの共通点を持っていますが、重要な場所で異なっています。

まず、クラスと構造体の共通点としては、以下のようなものがあります。

作成と命名ができる。
プロパティやメソッドを追加でき、プロパティオブザーバやアクセス制御も可能です。
カスタムイニシャライザを作成して、新しいインスタンスを好きなように構成することができます。
しかし、クラスは構造体と5つの点で異なります。

あるクラスは、別のクラスの機能を基に、そのクラスのすべてのプロパティとメソッドを出発点として構築することができます。あるクラスが別のクラスの機能をベースにして、そのプロパティとメソッドをすべて取得することができます。
その最初の点のために、Swiftは自動的にクラスのためのメンバー単位のイニシャライザーを生成することはありません。これは、あなた自身のイニシャライザーを書くか、すべてのプロパティにデフォルト値を割り当てる必要があることを意味します。
クラスのインスタンスをコピーするとき、両方のコピーが同じデータを共有します - 1 つのコピーを変更する場合、他のコピーも変更されます。
クラスインスタンスの最後のコピーが破棄されるとき、Swift はオプションで、deinitializer と呼ばれる特別な関数を実行することができます。
たとえクラスを定数にしたとしても、それらが変数である限り、そのプロパティを変更することができます。
表面上、これらはおそらくかなりランダムに見え、すでに構造体があるのに、なぜクラスが必要なのか不思議に思う可能性が高いでしょう。

しかし、SwiftUIは、主にポイント3のために、クラスを広範囲に使用します。これは、アプリの多くの部分が同じ情報を共有できることを意味し、ユーザーが1つの画面で名前を変更した場合、他のすべての画面は自動的にその変更を反映するために更新されます。

その他のポイントも重要ですが、使い道はさまざまです。

あるクラスをベースに別のクラスを構築できることは、Appleの古いUIフレームワークであるUIKitでは本当に重要ですが、SwiftUIアプリではあまり一般的ではありません。UIKitでは、クラスAがクラスBの上に構築され、クラスCの上に構築され、クラスDの上に構築されるなど、長いクラス階層を持つことが一般的でした。
もしクラスCが追加のプロパティを追加したら、C、B、Aのすべてのイニシャライザが壊れてしまうでしょう。
定数クラスの変数を変更できるということは、クラスのマルチコピー動作と関連しています。定数クラスは、コピーの指すポットを変更できませんが、プロパティが可変であれば、ポット内のデータを変更することができます。これは構造体とは異なる点で、構造体の各コピーは一意であり、独自のデータを保持します。
1つのクラスのインスタンスが複数の場所で参照される可能性があるため、最終的なコピーがいつ破棄されたかを知ることが重要になります。そこで登場するのがデインティライザです。デインティライザは、最後のコピーが破棄されたときに、割り当てた特別なリソースをクリーンアップすることができます。

その前に、クラスを作成し使用するコードのほんの一部を見てみましょう。


"""
class Game {
    var score = 0 {
        didSet {
            print("Score is now \(score)")
        }
    }
}

var newGame = Game()
newGame.score += 10
"""
そう、構造体との唯一の違いは、構造体ではなくクラスを使って作成されていることで、他はすべて同じです。クラスは冗長に見えるかもしれませんが、5つの違いすべてが重要なのです。

次の章でクラスと構造体の5つの違いについて詳しく説明しますが、今知っておくべき最も重要なことは、構造体もクラスも重要であり、SwiftUIを使うときにはどちらも必要であるということです。
"""
