//: [Previous](@previous)

import Foundation

"""
初期化子は、使用する新しい構造体のインスタンスを準備するために設計された特別なメソッドです。Swift が構造体の内部に配置したプロパティに基づいて、どのように黙って私たちのために1つを生成するかをすでに見てきましたが、1つの黄金律に従う限り、あなた自身を作成することもできます：すべてのプロパティは、初期化子が終了するまでに値を持っている必要があります。

構造体のためのSwiftのデフォルトのイニシャライザーをもう一度見ることから始めましょう。

"""
//struct Player {
//    let name: String
//    let number: Int
//}
//
//let player = Player(name: "Megan R", number: 15)
//print(player)
"""
それは、その2つのプロパティの値を提供することによって、新しいプレーヤーインスタンスを作成します。Swift はこれをメンバー単位のイニシャライザーと呼びます。これは、定義された順序で各プロパティを受け入れるイニシャライザーを言い表す空想の方法です。

私が言ったように、Swift がこれら二つの値を受け入れるイニシャライザーを黙って生成するので、この種のコードは可能ですが、同じことを行うために私たち自身を書くことができます。ここでの唯一のキャッチは、入ってくるパラメータの名前と割り当てられるプロパティの名前を区別するために注意しなければならないことです。

以下はその様子である。
"""
//struct Player {
//    let name: String
//    let number: Int
//
//    init(name: String, number: Int) {
//        self.name = name
//        self.number = number
//    }
//}
//let player = Player(name: "Megan R", number: 15)
//print(player)
"""
前のコードと同じように動作しますが、イニシャライザーは私たちが所有するので、必要であればそこに追加の機能を追加することができます。

しかし、いくつか注意してほしいことがあります。

funcキーワードがないことです。はい、これは構文の面で関数のように見えますが、Swift はイニシャライザーを特別に扱います。
これが新しい Player インスタンスを作成するとしても、イニシャライザーは決して明示的に戻り値の型を持ちません - 彼らは常に、それらが属しているデータの型を返します。
私は、私たちが「私の名前プロパティに名前パラメータを割り当てる」ことを意味することを明確にするために、プロパティにパラメータを割り当てるために self を使用しました。
なぜなら、selfがなければ、name = nameとなり、意味をなさないからだ。プロパティをパラメータに代入しているのか、パラメータを自分自身に代入しているのか、それとも他の何かなのか？self.nameと書くことで、「私の現在のインスタンスに属するnameプロパティ」という意味を明確にし、それ以外の意味とは区別しているのです。

もちろん、私たちのカスタムイニシャライザーは、Swiftが提供するデフォルトのメンバー単位のイニシャライザーのように動作する必要はありません。例えば、プレーヤー名を提供しなければならないが、シャツの番号はランダムであると言うことができます。
"""
struct Player {
    let name: String
    let number: Int

    init(name: String) {
        self.name = name
        number = Int.random(in: 1...99)
    }
}

let player = Player(name: "Megan R")
print(player.number)

"""
ただ、黄金律を覚えておいてください：イニシャライザが終了するまでに、すべてのプロパティは値を持たなければなりません。イニシャライザーの内部で number の値を提供しなかった場合、Swift はコードのビルドを拒否することでしょう。

重要：イニシャライザ内部で構造体の他のメソッドを呼び出すことができますが、すべてのプロパティに値を割り当てる前にそれを行うことはできません - Swift は、他の何かを行う前にすべてが安全であることを確認する必要があります。

必要であれば、構造体に複数のイニシャライザーを追加し、外部パラメーター名とデフォルト値などの機能を活用することができます。しかし、あなた自身のカスタム初期化子を実装するとすぐに、それを保持するための特別な手順を取らない限り、Swiftの生成されたメンバー単位の初期化子へのアクセスを失うことになります。これは偶然ではありません。カスタムのイニシャライザを持つ場合、Swiftは効果的にあなたがプロパティを初期化するためのいくつかの特別な方法を持っているので、それを仮定し、デフォルトのものはもはや利用できないはずであることを意味します。
"""

"""
構造体のためにカスタムのイニシャライザーを追加するとすぐに、デフォルトのメンバー単位のイニシャライザーは消えます。あなたがそれを維持したい場合は、次のように、拡張機能にカスタムイニシャライザを移動します。
"""
struct Employee {
    var name: String
    var yearsActive = 0
}

extension Employee {
    init() {
        self.name = "Anonymous"
        print("Creating an anonymous employee…")
    }
}

// creating a named employee now works
let roslin = Employee(name: "Laura Roslin")
print(roslin)
// as does creating an anonymous employee
let anon = Employee()



